Logback document

Logback is meant to be an improved version of Log4j, developed by the same developer who made Log4j.
At present time, logback is divided into three modules, logback-core, logback-classic and logback-access.

The logback-core module lays the groundwork for the other two modules. The logback-classic module can be assimilated to a significantly improved version of log4j 1.x. Moreover, logback-classic natively implements the SLF4J API so that you can readily switch back and forth between logback and other logging frameworks such as log4j 1.x or java.util.logging

Logback also has a lot more features compared to Log4j, with many of them being introduced into Log4j 2 as well. Here's a quick look at all of the advantages of Logback 

1.logback-classic speaks SLF4J natively
Since the Logger class in logback-classic implements the SLF4J API natively, you incur zero overhead when invoking an SLF4J logger with logback-classic as the underlying implementation. Moreover, since logback-classic strongly encourages the use of SLF4J as its client API, if you need to switch to log4j 1.x or to j.u.l., you can do so by replacing one jar file with another. You will not need to touch your code logging via the SLF4J API. This can drastically reduce the work involved in switching logging frameworks.

2.Automatic reloading of configuration files
Logback-classic can automatically reload its configuration file upon modification

3.Automatic removal of old log archives
By setting the maxHistory property of TimeBasedRollingPolicy or SizeAndTimeBasedFNATP, you can control the maximum number of archived files. If your rolling policy calls for monthly rollover and you wish to keep one year's worth of logs, simply set the maxHistory property to 12. Archived log files older than 12 months will be automatically removed.

4.Conditional processing of configuration files
Developers often need to juggle between several logback configuration files targeting different environments such as development, testing and production. These configuration files have substantial parts in common, differing only in a few places. To avoid duplication, logback supports conditional processing of configuration files with the help of <if>, <then> and <else> elements so that a single configuration file can adequately target several environments.

5. Filters
With logback, you have the option of keeping logging at the WARN level for all users except for the one user, say Alice, who is responsible for identifying the problem. When Alice is logged on, she will be logging at level DEBUG while other users can continue to log at the WARN level. This feat can be accomplished by adding 4 lines of XML to your configuration file. Search for MDCFilter in the relevant section of the manual

6.SiftingAppender
SiftingAppender is an amazingly versatile appender. It can be used to separate (or sift) logging according to any given runtime attribute. For example, SiftingAppender can separate logging events according to user sessions, so that the logs generated by each user go into distinct log files, one log file per user.

7.Logback-access, i.e. HTTP-access logging with brains, is an integral part of logback
Last but not least, the logback-access module, part of the logback distribution, integrates with Servlet containers such as Jetty or Tomcat to provide rich and powerful HTTP-access log functionality. Since logback-access was part of the initial design, all the logback-classic features you love are available in logback-access as well.

SLF4J
Simple Logging Facade for Java (abbreviated SLF4J) acts as a facade for different logging frameworks (e.g., java.util.logging, logback, Log4j). It offers a generic API, making the logging independent of the actual implementation.

This allows for different logging frameworks to coexist. And it helps migrate from one framework to another. Finally, apart from standardized API, it also offers some “syntactic sugar.”

Note that SLF4J-enabling your library/application implies the addition of only a single mandatory dependency, namely slf4j-api-2.0.6.jar.

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}
To run this example, you first need to obtain slf4j artifacts. Once that is done, add the file slf4j-api-2.0.6.jar to your class path.

Compiling and running HelloWorld will result in the following output being printed on the console.

SLF4J: No SLF4J providers were found.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
If you are using SLF4J 1.7 or earlier, the message would be:

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
This warning is printed because no slf4j provider (or binding) could be found on your class path.

The warning will disappear as soon as you add a provider to your class path. Assuming you add slf4j-simple-2.0.6.jar so that your class path contains:

slf4j-api-2.0.6.jar
slf4j-simple-2.0.6.jar
Compiling and running HelloWorld will now result in the following output on the console.

To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-2.0.6.jar with slf4j-log4j12-2.0.6.jar.


References: 
https://www.slf4j.org/manual.html


Logback

%d – outputs the time that the log message occurred in formats that SimpleDateFormat allows.
%thread – outputs the name of the thread that the log message occurred in.
$-5level – outputs the logging level of the log message.
%logger{36} – outputs the package + class name the log message occurred in. The number inside the brackets represents the maximum length of the package + class name. If the output is longer than the specified length, it will take a substring of the first character of each individual package starting from the root package until the output is below the maximum length. The class name will never be reduced. A nice diagram of this can be found in the Conversion Word docs.
%M – outputs the name of the method that the log message occurred in (apparently this is quite slow to use and not recommended unless you're not worried about performance, or if the method name is particularly important to you).
%msg – outputs the actual log message.
%n – line break.
%magenta() – sets the color of the output contained in the brackets to magenta (other colors are available).
highlight() – sets the color of the output contained in the brackets depending on the logging level (for example ERROR = red).

The available logging levels in Logback are:

OFF (output no logs)
ERROR
WARN
INFO
DEBUG
TRACE

//env based logging
//user based logging
//thread and traceId based logging
//package based logging
//logging on file


Appenders

 Logback allows logging requests to print to multiple destinations. In logback speak, an output destination is called an appender. Currently, appenders exist for the console, files, remote socket servers, to MySQL, PostgreSQL, Oracle and other databases, JMS, and remote UNIX Syslog daemons.
 More than one appender can be attached to a logger.
 
 Appenders must implement the ch.qos.logback.core.Appender interface
 
 The ch.qos.logback.core.​AppenderBase class is an abstract class implementing the Appender interface. It provides basic functionality shared by all appenders, such as methods for getting or setting their name, their activation status, their layout and their filters. It is the super-class of all appenders shipped with logback. Although an abstract class, AppenderBase actually implements the doAppend() method in the Append interface
 
 This implementation of the doAppend() method is synchronized. It follows that logging to the same appender from different threads is safe. While a thread, say T, is executing the doAppend() method, subsequent calls by other threads are queued until T leaves the doAppend() method, ensuring T's exclusive access to the appender.
 
	ConsoleAppender
 
 The ConsoleAppender, as the name indicates, appends on the console, or more precisely on System.out or System.err, the former being the default target. ConsoleAppender formats events with the help of an encoder specified by the user. Encoders will be discussed in a subsequent chapter. Both System.out and System.err are of type java.io.PrintStream. Consequently, they are wrapped inside an OutputStreamWriter which buffers I/O operations.
 
Property Name	Type	Description
encoder	- Encoder -	Describes how the output should be formatted.
target - String	- One of the String values System.out or System.err. The default target is System.out.

	FileAppender
	
The FileAppender, a subclass of OutputStreamAppender, appends log events into a file. The target file is specified by the File option. If the file already exists, it is either appended to, or truncated depending on the value of the append property.


Property Name	Type	Description
append - boolean - If true, events are appended at the end of an existing file. Otherwise, if append is false, any existing file is truncated. The append option is set to true by default.
encoder	- Encoder - See OutputStreamAppender properties.
file - String - The name of the file to write to. If the file does not exist, it is created. On the MS Windows platform users frequently forget to escape backslashes. For example, the value c:\temp\test.log is not likely to be interpreted properly as '\t' is an escape sequence interpreted as a single tab character (\u0009). Correct values can be specified as c:/temp/test.log or alternatively as c:\\temp\\test.log. The File option has no default value.
If the parent directory of the file does not exist, FileAppender will automatically create it, including any necessary but nonexistent parent directories.

	RollingFileAppender
RollingFileAppender extends FileAppender with the capability to rollover log files. For example, RollingFileAppender can log to a file named log.txt file and, once a certain condition is met, change its logging target to another file.

There are two important subcomponents that interact with RollingFileAppender.
RollingPolicy - responsible for undertaking the actions required for a rollover.
TriggeringPolicy - will determine if and exactly when rollover occurs.

To be of any use, a RollingFileAppender must have both a RollingPolicy and a TriggeringPolicy set up.

Property Name	Type	Description
file - String - See FileAppender properties. Note that file can be null in which case the output is written only to the target specified by the RollingPolicy.
append - boolean - See FileAppender properties.
encoder	- Encoder - See OutputStreamAppender properties.
rollingPolicy - RollingPolicy - This option is the component that will dictate RollingFileAppender's behavior when rollover occurs. See more information below.
triggeringPolicy - TriggeringPolicy - This option is the component that will tell RollingFileAppender when to activate the rollover procedure. See more information below.

RollingPolicy is responsible for the rollover procedure which involves file moving and renaming.

The RollingPolicy interface is presented below:

package ch.qos.logback.core.rolling;

import ch.qos.logback.core.FileAppender;
import ch.qos.logback.core.spi.LifeCycle;

public interface RollingPolicy extends LifeCycle {

  public void rollover() throws RolloverFailure;
  public String getActiveFileName();
  public CompressionMode getCompressionMode();
  public void setParent(FileAppender appender);
}
The rollover method accomplishes the work involved in archiving the current log file. 
The getActiveFileName() method is called to compute the file name of the current log file (where live logs are written to).
As indicated by getCompressionMode method a RollingPolicy is also responsible for determining the compression mode. 
Lastly, a RollingPolicy is given a reference to its parent via the setParent method.

	TimeBasedRollingPolicy

TimeBasedRollingPolicy is possibly the most popular rolling policy. It defines a rollover policy based on time, for example by day or by month.
Indeed, TimeBasedTriggeringPolicy implements both RollingPolicy and TriggeringPolicy interfaces.

Property Name	Type	Description
	fileNamePattern	- String
The mandatory fileNamePattern property defines the name of the rolled-over (archived) log files. Its value should consist of the name of the file, plus a suitably placed %d conversion specifier. The %d conversion specifier may contain a date-and-time pattern as specified by the java.text.SimpleDateFormat class. If the date-and-time pattern is omitted, then the default pattern yyyy-MM-dd is assumed. The rollover period is inferred from the value of fileNamePattern.
Note that the file property in RollingFileAppender (the parent of TimeBasedRollingPolicy) can be either set to a value or omitted (=null). By setting the file property of the containing FileAppender, you can decouple the location of the active log file and the location of the archived log files. The current logs will always be targeted at the file specified by the file property. It follows that the name of the currently active log file will not change over time.

However, if you choose to omit the file property, then the active file will be computed anew for each period based on the value of fileNamePattern. In this configuration no roll over occur, unless file compression is specified. The examples below should clarify this point.

The date-and-time pattern, as found within the accolades of %d{} follow java.text.SimpleDateFormat conventions. The forward slash '/' or backward slash '\' characters anywhere within the fileNamePattern property or within the date-and-time pattern will be interpreted as directory separators.

Multiple %d specifiers
It is possible to specify multiple %d specifiers but only one of which can be primary, i.e. used to infer the rollover period. All other tokens must be marked as auxiliary by passing the 'aux' parameter (see examples below).

Multiple %d specifiers allow you to organize archive files in a folder structure different than that of the roll-over period. For example, the file name pattern shown below organizes log folders by year and month but roll-over log files every day at midnight.

/var/log/%d{yyyy/MM, aux}/myapplication.%d{yyyy-MM-dd}.log
TimeZone
Under certain circumstances, you might wish to roll-over log files according to a clock in a timezone different than that of the host. It is possible to pass a timezone argument following the date-and-time pattern within the %d conversion specifier. For example:

aFolder/test.%d{yyyy-MM-dd-HH, UTC}.log
If the specified timezone identifier is unknown or misspelled, the GMT timezone is assumed as dictated by the TimeZone.getTimeZone(String) method specification.

	maxHistory	int	
The optional maxHistory property controls the maximum number of archive files to keep, asynchronously deleting older files. For example, if you specify monthly rollover, and set maxHistory to 6, then 6 months worth of archives files will be kept with files older than 6 months deleted. Note as old archived log files are removed, any folders which were created for the purpose of log file archiving will be removed as appropriate.

Setting maxHistory to zero disables archive removal. By default, maxHistory is set to zero, i.e. by default there is no archive removal.

	totalSizeCap	int	
The optional totalSizeCap property controls the total size of all archive files. Oldest archives are deleted asynchronously when the total size cap is exceeded. The totalSizeCap property requires maxHistory property to be set as well. Moreover, the "max history" restriction is always applied first and the "total size cap" restriction applied second.

The totalSizeCap property can be specified in units of bytes, kilobytes, megabytes or gigabytes by suffixing a numeric value with KB, MB and respectively GB. For example, 5000000, 5000KB, 5MB and 2GB are all valid values, with the first three being equivalent. A numerical value with no suffix is taken to be in units of bytes.

By default, totalSizeCap is set to zero, meaning that there is no total size cap.

	cleanHistoryOnStart	boolean	
If set to true, archive removal will be executed on appender start up. By default this property is set to false.

Archive removal is normally performed during roll over. However, some applications may not live long enough for roll over to be triggered. It follows that for such short-lived applications archive removal may never get a chance to execute. By setting cleanHistoryOnStart to true, archive removal is performed at appender start up.

Here are a few fileNamePattern values with an explanation of their effects.

	fileNamePattern	Rollover schedule	Example

/wombat/foo.%d
	Daily rollover (at midnight). Due to the omission of the optional time and date pattern for the %d token specifier, the default pattern of yyyy-MM-dd is assumed, which corresponds to daily rollover.	
	
	file property not set: During November 23rd, 2006, logging output will go to the file /wombat/foo.2006-11-23. At midnight and for the rest of the 24th, logging output will be directed to /wombat/foo.2006-11-24.

	file property set to /wombat/foo.txt: During November 23rd, 2006, logging output will go to the file /wombat/foo.txt. At midnight, foo.txt will be renamed as /wombat/foo.2006-11-23. A new /wombat/foo.txt file will be created and for the rest of November 24th logging output will be directed to foo.txt.

/wombat/%d{yyyy/MM}/foo.txt
	Rollover at the beginning of each month.	

	file property not set: During the month of October 2006, logging output will go to /wombat/2006/10/foo.txt. After midnight of October 31st and for the rest of November, logging output will be directed to /wombat/2006/11/foo.txt.

	file property set to /wombat/foo.txt: The active log file will always be /wombat/foo.txt. During the month of October 2006, logging output will go to /wombat/foo.txt. At midnight of October 31st, /wombat/foo.txt will be renamed as /wombat/2006/10/foo.txt. A new /wombat/foo.txt file will be created where logging output will go for the rest of November. At midnight of November 30th, /wombat/foo.txt will be renamed as /wombat/2006/11/foo.txt and so on.

/wombat/foo.%d{yyyy-ww}.log	
	Rollover at the first day of each week.
	
	Note that the first day of the week depends on the locale.	Similar to previous cases, except that rollover will occur at the beginning of every new week.
	
/wombat/foo%d{yyyy-MM-dd_HH}.log
	Rollover at the top of each hour.	
	
/wombat/foo%d{yyyy-MM-dd_HH-mm}.log
	Rollover at the beginning of every minute.
	
/wombat/foo%d{yyyy-MM-dd_HH-mm, UTC}.log
	Rollover at the beginning of every minute.
	
/foo/%d{yyyy-MM,aux}/%d.log	
	Rollover daily. Archives located under a folder containing year and month.	
	In this example, the first %d token is marked as auxiliary. The second %d token, with time and date pattern omitted, is then assumed to be primary. Thus, rollover will occur daily (default for %d) and the folder name will depend on the year and month. For example, during the month of November 2006, archived files will all placed under the /foo/2006-11/ folder, e.g /foo/2006-11/2006-11-14.log.
	
Any forward or backward slash characters are interpreted as folder (directory) separators. Any required folder will be created as necessary. You can thus easily place your log files in separate folders.

Automatic file compression
TimeBasedRollingPolicy supports automatic file compression. This feature is enabled if the value of the fileNamePattern option ends with .gz or .zip.

fileNamePattern	Rollover schedule	Example
/wombat/foo.%d.gz	Daily rollover (at midnight) with automatic GZIP compression of the archived files.	
file property not set: During November 23rd, 2009, logging output will go to the file /wombat/foo.2009-11-23. However, at midnight that file will be compressed to become /wombat/foo.2009-11-23.gz. For the 24th of November, logging output will be directed to /wombat/folder/foo.​2009-11-24 until it's rolled over at the beginning of the next day.

file property set to /wombat/foo.txt: During November 23rd, 2009, logging output will go to the file /wombat/foo.txt. At midnight that file will be compressed and renamed as /wombat/foo.2009-11-23.gz. A new /wombat/foo.txt file will be created where logging output will go for the rest of November 24th. At midnight November 24th, /wombat/foo.txt will be compressed and renamed as /wombat/foo.2009-11-24.gz and so on.

Size and time based rolling policy
Sometimes you may wish to archive files essentially by date but at the same time limit the size of each log file, in particular if post-processing tools impose size limits on the log files. In order to address this requirement, logback ships with SizeAndTimeBasedRollingPolicy.

Note the "%i" conversion token in addition to "%d". Both the %i and %d tokens are mandatory. Each time the current log file reaches maxFileSize before the current time period ends, it will be archived with an increasing index, starting at 0.

	Encoder interface
Encoders are responsible for transforming an incoming event into a byte array and writing out the resulting byte array onto the appropriate OutputStream. Thus, encoders have total control of what and when bytes get written to the OutputStream maintained by the owning appender.

Encoders were introduced in logback version 0.9.19. In previous versions, most appenders relied on a layout to transform an event into a string and write it out using a java.io.Writer.

layout has no control over when events get written out, layouts cannot aggregate events into batches. Contrast this with encoders which not only have total control over the format of the bytes written out, but also control when (and if) those bytes get written out.

	LayoutWrappingEncoder
Until logback version 0.9.19, many appenders relied on the Layout instances to control the format of log output. As there exists substantial amount of code based on the layout interface, we needed a way for encoders to interoperate with layouts. LayoutWrappingEncoder bridges the gap between encoders and layouts. It implements the encoder interface and wraps a layout to which it delegates the work of transforming an event into string.

The doEncode() method starts by having the wrapped layout convert the incoming event into string. The resulting text string is converted to bytes according to the charset encoding chosen by the user.

PatternLayoutEncoder
Given that PatternLayout is the most commonly used layout, logback caters for this common use-case with PatternLayoutEncoder, an extension of LayoutWrappingEncoder restricted to wrapping instances of PatternLayout.

PatternLayout

As all layouts, PatternLayout takes a logging event and returns a String. However, this String can be customized by tweaking PatternLayout's conversion pattern.

FileAppender and subclasses expect an encoder.
 logback ships with an encoder named PatternLayoutEncoder, designed solely for the purpose of wrapping a PatternLayout instance so that it can be seen as encoder.

remaining tasks
additivity demo
doAppend logic
prudent mode
profile based logging
Conditional logging

Sout vs logging- https://www.baeldung.com/java-system-out-println-vs-loggers#:~:text=With%20the%20use%20of%20Loggers,timestamp%2C%20method%20name%2C%20etc.

user manual- https://www.slf4j.org/manual.html

https://stackify.com/logging-logback/
