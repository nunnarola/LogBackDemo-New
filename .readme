Logback document

Logback is meant to be an improved version of Log4j, developed by the same developer who made Log4j.
At present time, logback is divided into three modules, logback-core, logback-classic and logback-access.

The logback-core module lays the groundwork for the other two modules. The logback-classic module can be assimilated to a significantly improved version of log4j 1.x. Moreover, logback-classic natively implements the SLF4J API so that you can readily switch back and forth between logback and other logging frameworks such as log4j 1.x or java.util.logging

Logback also has a lot more features compared to Log4j, with many of them being introduced into Log4j 2 as well. Here's a quick look at all of the advantages of Logback 

1.logback-classic speaks SLF4J natively
Since the Logger class in logback-classic implements the SLF4J API natively, you incur zero overhead when invoking an SLF4J logger with logback-classic as the underlying implementation. Moreover, since logback-classic strongly encourages the use of SLF4J as its client API, if you need to switch to log4j 1.x or to j.u.l., you can do so by replacing one jar file with another. You will not need to touch your code logging via the SLF4J API. This can drastically reduce the work involved in switching logging frameworks.

2.Automatic reloading of configuration files
Logback-classic can automatically reload its configuration file upon modification

3.Automatic removal of old log archives
By setting the maxHistory property of TimeBasedRollingPolicy or SizeAndTimeBasedFNATP, you can control the maximum number of archived files. If your rolling policy calls for monthly rollover and you wish to keep one year's worth of logs, simply set the maxHistory property to 12. Archived log files older than 12 months will be automatically removed.

4.Conditional processing of configuration files
Developers often need to juggle between several logback configuration files targeting different environments such as development, testing and production. These configuration files have substantial parts in common, differing only in a few places. To avoid duplication, logback supports conditional processing of configuration files with the help of <if>, <then> and <else> elements so that a single configuration file can adequately target several environments.

5. Filters
With logback, you have the option of keeping logging at the WARN level for all users except for the one user, say Alice, who is responsible for identifying the problem. When Alice is logged on, she will be logging at level DEBUG while other users can continue to log at the WARN level. This feat can be accomplished by adding 4 lines of XML to your configuration file. Search for MDCFilter in the relevant section of the manual

6.SiftingAppender
SiftingAppender is an amazingly versatile appender. It can be used to separate (or sift) logging according to any given runtime attribute. For example, SiftingAppender can separate logging events according to user sessions, so that the logs generated by each user go into distinct log files, one log file per user.

7.Logback-access, i.e. HTTP-access logging with brains, is an integral part of logback
Last but not least, the logback-access module, part of the logback distribution, integrates with Servlet containers such as Jetty or Tomcat to provide rich and powerful HTTP-access log functionality. Since logback-access was part of the initial design, all the logback-classic features you love are available in logback-access as well.

SLF4J
Simple Logging Facade for Java (abbreviated SLF4J) acts as a facade for different logging frameworks (e.g., java.util.logging, logback, Log4j). It offers a generic API, making the logging independent of the actual implementation.

This allows for different logging frameworks to coexist. And it helps migrate from one framework to another. Finally, apart from standardized API, it also offers some “syntactic sugar.”

Note that SLF4J-enabling your library/application implies the addition of only a single mandatory dependency, namely slf4j-api-2.0.6.jar.

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}
To run this example, you first need to obtain slf4j artifacts. Once that is done, add the file slf4j-api-2.0.6.jar to your class path.

Compiling and running HelloWorld will result in the following output being printed on the console.

SLF4J: No SLF4J providers were found.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
If you are using SLF4J 1.7 or earlier, the message would be:

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
This warning is printed because no slf4j provider (or binding) could be found on your class path.

The warning will disappear as soon as you add a provider to your class path. Assuming you add slf4j-simple-2.0.6.jar so that your class path contains:

slf4j-api-2.0.6.jar
slf4j-simple-2.0.6.jar
Compiling and running HelloWorld will now result in the following output on the console.

To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-2.0.6.jar with slf4j-log4j12-2.0.6.jar.


References: 
https://www.slf4j.org/manual.html


Logback

%d – outputs the time that the log message occurred in formats that SimpleDateFormat allows.
%thread – outputs the name of the thread that the log message occurred in.
$-5level – outputs the logging level of the log message.
%logger{36} – outputs the package + class name the log message occurred in. The number inside the brackets represents the maximum length of the package + class name. If the output is longer than the specified length, it will take a substring of the first character of each individual package starting from the root package until the output is below the maximum length. The class name will never be reduced. A nice diagram of this can be found in the Conversion Word docs.
%M – outputs the name of the method that the log message occurred in (apparently this is quite slow to use and not recommended unless you're not worried about performance, or if the method name is particularly important to you).
%msg – outputs the actual log message.
%n – line break.
%magenta() – sets the color of the output contained in the brackets to magenta (other colors are available).
highlight() – sets the color of the output contained in the brackets depending on the logging level (for example ERROR = red).

The available logging levels in Logback are:

OFF (output no logs)
ERROR
WARN
INFO
DEBUG
TRACE

//env based logging
//user based logging
//thread and traceId based logging
//package based logging
//logging on file


Appenders and Layouts

 Logback allows logging requests to print to multiple destinations. In logback speak, an output destination is called an appender. Currently, appenders exist for the console, files, remote socket servers, to MySQL, PostgreSQL, Oracle and other databases, JMS, and remote UNIX Syslog daemons.
 More than one appender can be attached to a logger.
 
